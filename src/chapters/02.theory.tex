\chapter{Background for understanding Kdyby}

\section{A brief history of Kdyby} \label{sec:theory:kdyby-history}

In 2006 I have started working on my own \gls{cms}~\cite{wiki:cms}. A prototype was used in production on few websites I created. The oldest preserved version is \fnurl{archived on my Github}{https://github.com/fprochazka/kdyby-cms-old}. It is a great learning material on how to not write a CMS.

Then the concept of \gls{oss}~\cite{wiki:oss} was introduced to me and I have decided to start working on everything openly, under a free license~\cite{wiki:fsl}. Mo new working version of Kdyby CMS was released since then, because I have rewritten it from scratch exactly 10 times.

In 2012, I have decomposed the entire system into separate libraries that can be used more or less independently and have their own release cycle. This approach was preserved to this day.

\section{Techniques and design patterns}

\hiddensubsection{Dependency Injection} \label{sec:theory:di}

Inversion of control is a design principle in which custom-written portions of a computer program receive the flow of control from a generic framework.

\Gls{di} is a technique whereby one object supplies the dependencies of another object. Passing the service to the client, rather than allowing a client to build or find the service, is the fundamental requirement of the pattern~\cite{fowler:di}.

\hiddensubsection{Aspect Oriented Programming} \label{sec:theory:aop}

In computing, \gls{aop} is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. It does so by adding additional behavior to existing code (an advice) without modifying the code itself, instead separately specifying which code is modified via a pointcut specification, such as log all function calls when the name of the function begins with 'set'. This allows behaviors that are not central to the business logic (such as logging) to be added to a program without cluttering the code core to the functionality~\cite{wiki:aop}.

\hiddensubsection{Event Dispatcher} \label{sec:theory:event-dispatcher}

The Event Dispatcher is a pattern for writing modular code. It allows to create extension points in the library or application that another library or application can hook into and change or extend the behavior.

Typically, the extension points are called hooks or events and the new functionality is provided with objects called listeners.

\section{Technologies used}

\hiddensubsection{Git and Github} \label{sec:theory:git}

Git is a Version Control System that is decentralized and considered very fast~\cite{progit}. Github is a collaboration platform for software development using Git.

Each project has a page on Github called a repository that can be used to inspect the Git history, files and other metadata. On the project repository page, there are issues and pull requests. Pull requests are a way to ask the maintainer of the repository to incorporate provided code patch to the repository. It can be a bugfix or feature.

There are tools around pull requests that allow collaboration, a code review and discussion about the provided code, so that the maintainers can help the contributors to provide the best code possible.

Kdyby is hosted and developed on Github, with the help of several other maintainers and the community that contributes bugfixes and features.

\hiddensubsection{Continuous Integration} \label{sec:theory:ci}

\gls{ci} is a practice of merging all developer working copies to a shared mainline several times a day, to prevent merging conflicts.~\cite{wiki:ci} But now-days, the term has established to mean CI servers that run prepared task on the provided code.

In practice, it means that as the developer is working on a feature or bugfix, they push the work in progress code into a repository, the code is then picked up by a CI server that executes the tests, checks coding style and runs various other tasks to verify that the code was not broken.

When the work is finished and all the task on CI server completed with success, the code can be probably safely integrated, providing that the tests for new or changed functionality were added.

Some popular CI services are \fnurl{Travis~CI}{https://travis-ci.org/}, \fnurl{CircleCI}{https://circleci.com/} and \fnurl{GitLab~CI}{https://about.gitlab.com/features/gitlab-ci-cd/}. Kdyby is using the Travis~CI that is free for \gls{oss} projects.

\hiddensubsection{Semantic Versioning} \label{sec:theory:semver}

\gls{semver} is a standard that defines how software should be versioned in order to allow safe upgrading. Application might be written with a specific release of the library and upgrading to the newest version might break it because of dropped compatibility. \fnurl{\gls{semver}}{http://semver.org/} defines major, minor and patch releases that signal what versions are compatible with each other.

\hiddensubsection{Nette Framework} \label{sec:theory:nette}

\gls{nette} is an \gls{oss} framework for creating web applications in PHP~\cite{wiki:nette}. \gls{nette} is separated into many packages.

The \gls{di} component \fnurl{nette/di}{https://github.com/nette/di} provides a \gls{dic} that holds the services. The component also allows to prepare a preconfigured \gls{dic}, which is then compiled into a PHP class that contains optimized code for the service creation. This compiled \gls{dic} class is cached for reuse. There is a concept (and a class) CompilerExtension that allows the developer to hook into the process of configuring and compiling of the \gls{nette} \gls{dic}. All of Kdyby packages that are an integration of some other library or tool into \gls{nette} provide a CompilerExtension to make the installation easy.

\hiddensubsection{Composer} \label{sec:theory:composer}

Composer is a tool for dependency management~\cite{wiki:package-manager} in PHP. It allows you to declare the libraries your project depends on and it will manage (install or update) them for you~\cite{composer:docs:intro}.

Packages are usually published using Github with metadata in a file named \lstinline{composer.json} that is written in JSON~\cite{wiki:json} format.

Composer is decentralized, but has a single main metadata repository \fnurl{Packagist}{https://packagist.org/}. It stores and provides all the package metadata like available versions and where to download them.

All Kdyby libraries are published as Composer packages on Packagist and installing them using the Composer is the only officially supported installation method.

\hiddensubsection{OAuth 2} \label{sec:theory:oauth2}

OAuth is a protocol for authentication and authorization that can be implemented into a web service. It is designed for secure exchange of user information, allowing third party websites to implement a login and registration process that simplifies these tasks for the user essentially allowing them to login or register to services through the OAuth 2 provider with two clicks.

Kdyby provides packages for integrating \gls{nette} with OAuth 2 providers, such as \fnurl{Facebook}{https://developers.facebook.com/docs/facebook-login/manually-build-a-login-flow}, \fnurl{Google}{https://developers.google.com/identity/protocols/OAuth2} and \fnurl{Github}{https://developer.github.com/v3/oauth/}.

\hiddensubsection{dibi} \label{sec:theory:dibi}

Dibi is a Database Abstraction Library for PHP. It supports a lot of significant databases: MySQL, PostgreSQL, SQLite, MS SQL, Oracle, Access and generic PDO and ODBC~\cite{dibi:homepage}.

\hiddensubsection{Doctrine 2 ORM} \label{sec:theory:doctrine}

\gls{doctrine} is an \gls{orm}~\cite{wiki:orm}, which means it allows the programmer to create PHP classes called entities that represent relational data in a database and are used to actually map the data from the database to the classes and back. In conclusion, it allows the programmer to write fully \gls{oo}~\cite{wiki:oop} applications.

\hiddensubsection{Symfony Framework} \label{sec:theory:symfony}

\gls{sf} is a PHP web application framework and a set of reusable PHP components/libraries, similar to \gls{nette}~\cite{wiki:symfony}.

For extensibility, \gls{sf} has Bundles that provide similar functionality to \gls{nette} CompilerExtension, but they operate on a different level of abstractions. Bundle is a whole package that contains the Bundle definition, \gls{dic} extension for configuring the Bundle and it may contain adapter classes. Bundles are registered in the AppKernel of Symfony application.

\hiddensubsection{RabbitMQ} \label{sec:theory:rabbitmq}

RabbitMQ is \gls{oss} message broker software (sometimes called message-oriented middleware) that implements the \gls{amqp}. The RabbitMQ server is written in the Erlang programming language and is built on the Open Telecom Platform framework for clustering and failover~\cite{wiki:rabbitmq}.

\hiddensubsection{ElasticSearch} \label{sec:theory:elasticsearch}

\gls{elastic} is a search engine based on Lucene. It provides a distributed, multitenant-capable full-text search engine with an HTTP web interface and schema-free JSON documents. \gls{elastic} is developed in Java and is released as open source under the terms of the Apache License. It is the most popular enterprise search engine~\cite{wiki:elasticsearch}.

\hiddensubsection{Redis} \label{sec:theory:redis}

Redis is an in-memory database \gls{oss} project that is networked, in-memory, and stores keys with optional durability~\cite{wiki:redis}.

\hiddensubsection{PhpStan} \label{sec:theory:phpstan}

PHPStan focuses on finding errors in your code without actually running it. It catches whole classes of bugs even before you write tests for the code~\cite{github:phpstan}.

\hiddensubsection{PHP Standards Recommendations} \label{sec:theory:psr}

The \gls{fig}, which is a group of representatives from established \gls{oss} projects, discusses and creates \gls{psr}. The goal is to discover commonalities in libraries that solve similar problems. The PHP ecosystem is fragmented around tens of frameworks and libraries that all do the same, but slightly differently. This is hugely caused by the absence of a good dependency management tool like Composer, which is still very young. The \gls{psr} contain interfaces that were agreed upon for the libraries to implement. The accepted standards are listed at the \fnurl{\gls{fig} website}{http://www.php-fig.org/psr/}~\cite{fig:psr}.

\hiddensubsection{Monolog} \label{sec:theory:monolog}

Monolog is a logging library that sends your logs to files, sockets, inboxes, databases and various web services. This library implements the PSR-3 logging interface that can be typehinted against in other libraries to keep maximum of interoperability~\cite{monolog:readme}.

\hiddensubsection{Nette\textbackslash{}Tester} \label{sec:theory:nette-tester}

Nette\textbackslash{}Tester is a unit testing framework for PHP~\cite{tester:docs}. Its main advantage over other unit testing libraries is that by default every test runs in single process and the tests are executed in parallel making them run faster, in better isolation and they cannot depend on specific order of execution.
